<?xml version="1.0" encoding="UTF-8"?>
<jcr:root xmlns:jcr="http://www.jcp.org/jcr/1.0" xmlns:cq="http://www.day.com/jcr/cq/1.0" xmlns:mix="http://www.jcp.org/jcr/mix/1.0" xmlns:nt="http://www.jcp.org/jcr/nt/1.0" xmlns:sling="http://sling.apache.org/jcr/sling/1.0"
          jcr:primaryType="cq:Page">
  <jcr:content
    cq:template="/apps/wcm-io-samples/sample-app/templates/content/content"
    jcr:primaryType="cq:PageContent"
    jcr:title="System programming"
    sling:resourceType="/apps/wcm-io-samples/sample-app/components/content/page/content">
    <content
      jcr:primaryType="nt:unstructured"
      sling:resourceType="wcm-io/wcm/parsys/components/parsys">
      <contentheadline
        jcr:primaryType="nt:unstructured"
        sling:resourceType="wcm-io-samples/sample-app/components/content/common/contentHeadline"
        headline="System programming" />
      <contentrichtext
        jcr:primaryType="nt:unstructured"
        sling:resourceType="wcm-io-samples/sample-app/components/content/common/contentRichText"
        text="&lt;p&gt;&amp;apos;&amp;apos;&amp;apos;System programming&amp;apos;&amp;apos;&amp;apos; (or &amp;apos;&amp;apos;&amp;apos;systems programming&amp;apos;&amp;apos;&amp;apos;) is the activity of [[computer programming]] [[system software]]. The primary distinguishing characteristic of systems programming when compared to [[application programming]] is that [[application software|application]] programming aims to produce software which provides services to the user (e.g. [[word processor]]), whereas systems programming aims to produce software which provides services to the [[computer hardware]] (e.g. [[Defragmentation|disk defragmenter]]). It requires a greater degree of hardware awareness.

== Overview ==
The following attributes characterize systems programming:
* The [[programmer]] will make assumptions about the hardware and other properties of the system that the program runs on, and will often exploit those properties, for example by using an [[algorithm]] that is known to be efficient when used with specific hardware.
* Usually a low-level programming language or programming language dialect is used that:
** can operate in resource-constrained environments
** is very efficient and has little [[Run-time system|runtime]] overhead
** has a small [[runtime library]], or none at all
** allows for direct and &amp;quot;raw&amp;quot; control over memory access and [[control flow]]
** lets the programmer write parts of the program directly in [[assembly language]]
* Often systems programs cannot be run in a [[debugger]]. Running the program in a [[computer simulation|simulated environment]] can sometimes be used to reduce this problem.

Systems programming is sufficiently different from application programming that programmers tend to specialize in one or the other.

In system programming, often limited programming facilities are available. The use of [[garbage collection (computer science)|automatic garbage collection]] is not common and [[debugging]] is sometimes hard to do. The [[runtime library]], if available at all, is usually far less powerful, and does less error checking. Because of those limitations, [[System monitoring|monitoring]] and [[data logging|logging]] are often used; [[operating system]]s may have extremely elaborate logging subsystems.

Implementing certain parts in operating system and networking requires systems programming, for example implementing Paging ([[Virtual Memory]]) or a [[device driver]] for an operating system.

== History ==
Originally systems programmers invariably wrote in [[assembly language]]. Experiments with hardware support in [[high level languages]] in the late 1960s led to such languages as [[IBM PL/S|PL/S]], [[BLISS]], [[BCPL]], and extended [[ALGOL]] for [[Burroughs large systems]]. [[Forth (programming language)|Forth]] also has applications as a systems language.
In the 1980s, [[C (programming language)|C]] became ubiquitous, aided by the growth of [[Unix]].
More recently [[C++]] has seen some use, for instance a subset of it is used in the [[I/O Kit]] drivers of [[Mac OS X]].{{cn|date=April 2013}}

== Alternate usage ==
For historical reasons, some organizations use the term &amp;apos;&amp;apos;systems programmer&amp;apos;&amp;apos; to describe a job function which would be more accurately termed [[systems administrator]].  This is particularly true in organizations whose computer resources have historically been dominated by [[Mainframe computer|mainframe]]s, although the term is even used to describe job functions which do not involve mainframes. This usage arose because administration of [[IBM mainframes]] often involved the writing of custom [[assembler code]] (IBM&amp;apos;s Basic Assembly Language - &amp;quot;BAL&amp;quot;), which integrated with the [[Operating System]] such as [[OS/MVS]], [[DOS/VSE]] or [[VM/CMS]].  Indeed, some [[IBM]] software products had substantial code contributions from customer programming staff. This type of programming is progressively less common, but the term &amp;apos;&amp;apos;systems programmer&amp;apos;&amp;apos; is still the defacto job title for staff directly administering IBM mainframes.

== See also ==
* [[computer programming]]

* [[Ousterhout&amp;apos;s dichotomy]]
* [[system programming language]]
* [[scripting language]]

== References ==
{{Unreferenced|date=April 2007}}

==Further reading==
* [http://catalog.loc.gov/cgi-bin/Pwebrecon.cgi?v1=5&amp;amp;ti=1,5&amp;amp;Search_Arg=Donovan%2C%20John%20J.&amp;amp;Search_Code=NAME%40&amp;amp;CNT=100&amp;amp;PID=fahdDtIh7Y1ODWe5X_fO2_UUafeDT&amp;amp;SEQ=20090914123346&amp;amp;SID=1 Systems Programming] by [[Anowar CST]]

{{DEFAULTSORT:System Programming}}
[[Category:Computer programming]]
[[Category:System software]]&lt;/p&gt;" />
    </content>
  </jcr:content>
</jcr:root>
